<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Advanced Network Analysis</title>
    <meta charset="utf-8" />
    <meta name="author" content="Olga Chyzh [www.olgachyzh.com]" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Advanced Network Analysis
## Stochastic Actor-Oriented Models
### Olga Chyzh [www.olgachyzh.com]

---


exclude: true



## Readings 

- Christian Steglich, Tom AB Snijders, and Michael Pearson. Dynamic networks and behavior: Separating selection from in
uence. Sociological Methodology, 40(1):329--393, 2010.

---

# SAOM

Stochastic actor oriented model developed primarily by [Snijders](https://www.stats.ox.ac.uk/~snijders/) is implemented in the RSiena package on CRAN: 
- [https://www.stats.ox.ac.uk/~snijders/siena/](https://www.stats.ox.ac.uk/~snijders/siena/)
- [Recent overview piece by Snijders](https://www.annualreviews.org/doi/10.1146/annurev-statistics-060116-054035)

&lt;img src="images/siena.png" width="500px" style="display: block; margin: auto;" /&gt;

---

## SAOM Assumptions

- Actors control their outgoing ties and have full knowledge of broader network

--

- Evolution of network process occurs in microsteps

--

- Only one tie can change at a microstep

--

- Tie change only depends on the present network

---

## SAOM Broadstrokes

- The simulation starts out at the network observed at the first time point `\(t_{0}\)`

--

- An actor is chosen randomly using a &lt;span style="background-color: #d0d1e6"&gt;rate function&lt;/span&gt;

--

- The identified actor gets the opportunity to set a micro step. The actor's choice is determined by their &lt;span style="background-color: #d0d1e6"&gt;objective function&lt;/span&gt;

--

- Model time is updated and simulation proceeds at step 2

--

- The simulation terminates once modified network resembles network at `\(t_{1}\)`

---

## Rate Function

- Waiting time until change can be made by any actor follows an exponential distribution with parameter `\(\lambda_{t} g\)` ( `\(g\)` refers to number of actors in the network)

--

	+ Values of `\(\lambda_{t}\)` are estimated by calculating the number of edge differences between networks: 

--

	+ The higher `\(\lambda_{t}\)` is the greater the number of changes between observation moments 

--

- Probability that an actor `\(i\)` has the opportunity to make a change is equal to `\(1/g\)`

---

## Actor's Objective Function

`\(f_{i}(\beta, x(i \leadsto j)) = \sum_{l=1}^{k} \beta_{l} s_{il} (x(i \leadsto j)) + U_{i}(t,x,j)\)`, where

--

- `\(s_{il} (x(i \leadsto j))\)` represents `\(k\)` structural and exogenous effects 

--

-  `\(\beta_{l}\)` are statistical parameters 

--

- and `\(U_{i}(t,x,j)\)` is a random utility term

---

## Multinomial Choice Model

&lt;!-- $ p_{ij}(\beta, x(i \leadsto j)) = \dfrac{ exp(f_{i}(\beta, x(i \leadsto j))) }{ \sum_{h=1}^{g} exp(f_{i}(\beta, x(i \leadsto h)))  }  $ --&gt;

&lt;img src="images/saom_choice.png" width="500px" style="display: block; margin: auto;" /&gt;

--

- Represents the probability with which actor `\(i\)` changes his outgoing ties  

--

- When `\(i=j\)` this probability refers to the probability of not changing anything  

---

## Parameter Estimation

Solving the model requires the estimation of `\(\boldsymbol\theta = (\boldsymbol\lambda, \boldsymbol\beta)\)` using a Method of Moments approach (MoM)

--

- Suitable statistic for `\(\boldsymbol\lambda\)`: 

&lt;img src="images/suitable_lambda.png" width="300px" style="display: block; margin: auto;" /&gt;

--

- Suitable statistic for `\(\boldsymbol\beta\)`:

&lt;img src="images/suitable_beta.png" width="230px" style="display: block; margin: auto;" /&gt;

---

## Stochastic Approximation Process

Combining the suitable statistics, we next determine the value `\(\hat{\boldsymbol\theta}\)` for `\(\boldsymbol\theta\)` as the solution of the system of equations:

`\begin{align}
	g_{n}(\boldsymbol\theta | z_{n}) = \sum_{t_{a} \in T} (E_{\boldsymbol\theta} \{ u(Y^{(a+1)} | Y^{(a)} = y^{(a)})  \} - u(y^{(a+1)}) ), 
\end{align}`

--

- `\(z_{n}\)` simply means all available data

--

- `\(u(x)\)` corresponds to the statistic being estimated

--

- The estimation for the MoM relies on MCMC simulations of the network change process (Robbins &amp; Monro, 1951)

---

## Example: Friendship Networks


```r
library(RSiena)
	friend.data.w1 &lt;- s501
	friend.data.w2 &lt;- s502
	friend.data.w3 &lt;- s503
	drink &lt;- s50a
	smoke &lt;- s50s
```

---

## Specify the Network DV:


```r
friendship &lt;- sienaDependent(
                     array( c( friend.data.w1, friend.data.w2, friend.data.w3 ),
                     dim = c( 50, 50, 3 ) ) )
```

.pull-left[

```r
friendship
```

```
## Type         oneMode             
## Observations 3                   
## Nodeset      Actors (50 elements)
```

```r
class(friendship)
```

```
## [1] "sienaDependent"
```

```r
dim( friendship)
```

```
## [1] 50 50  3
```
]

.pull-right[

```r
attributes(friendship)
```

```
## $dim
## [1] 50 50  3
## 
## $class
## [1] "sienaDependent"
## 
## $type
## [1] "oneMode"
## 
## $sparse
## [1] FALSE
## 
## $nodeSet
## [1] "Actors"
## 
## $netdims
## [1] 50 50  3
## 
## $allowOnly
## [1] TRUE
```
]

---

## Specify the Behavior DV:


```r
drinkingbeh &lt;- sienaDependent( drink, type = "behavior" )
drinkingbeh
```

```
## Type         behavior            
## Observations 3                   
## Nodeset      Actors (50 elements)
```

---

## Specify IVs:


```r
smoke1 &lt;- coCovar( smoke[ , 1 ] )

# Put the variables together in the data set for analysis
NBdata &lt;- sienaDataCreate( friendship, smoke1, drinkingbeh)
NBdata                          
```

```
## Dependent variables:  friendship, drinkingbeh 
## Number of observations: 3 
## 
## Nodeset                  Actors 
## Number of nodes              50 
## 
## Dependent variable friendship      
## Type               oneMode         
## Observations       3               
## Nodeset            Actors          
## Densities          0.046 0.047 0.05
## 
## Dependent variable drinkingbeh
## Type               behavior   
## Observations       3          
## Nodeset            Actors     
## Range              1 - 5      
## 
## Constant covariates:  smoke1
```


---
## Possible Types of IVs

- `coCovar`--constant node-level covariate (does not change between time periods)

- `varCovar`--time-variable node-level covariate

- `coDyadCovar`--constant edge-level covariate

- `varDyadCovar`--time-varying edge-level covariate

- `sienaCompositionChange`--over time changes in node set (e.g., some actors leave the network)


```r
?coCovar
```


---

## Specify Endogenous Effects

```r
NBeff &lt;- getEffects( NBdata )
NBeff
```

```
##   name        effectName                          include fix   test 
## 1 friendship  constant friendship rate (period 1) TRUE    FALSE FALSE
## 2 friendship  constant friendship rate (period 2) TRUE    FALSE FALSE
## 3 friendship  outdegree (density)                 TRUE    FALSE FALSE
## 4 friendship  reciprocity                         TRUE    FALSE FALSE
## 5 drinkingbeh rate drinkingbeh (period 1)         TRUE    FALSE FALSE
## 6 drinkingbeh rate drinkingbeh (period 2)         TRUE    FALSE FALSE
## 7 drinkingbeh drinkingbeh linear shape            TRUE    FALSE FALSE
## 8 drinkingbeh drinkingbeh quadratic shape         TRUE    FALSE FALSE
##   initialValue parm
## 1    4.69604   0   
## 2    4.32885   0   
## 3   -1.46770   0   
## 4    0.00000   0   
## 5    0.70571   0   
## 6    0.84939   0   
## 7    0.32237   0   
## 8    0.00000   0
```

---

## Effects Description

```r
effectsDocumentation(NBeff)
```


&lt;img src="images/effects.png" width="500px" style="display: block; margin: auto;" /&gt;

---

## Specify Effects


```r
NBeff &lt;- includeEffects( NBeff, transTrip, transRecTrip )
```

```
##   effectName                  include fix   test  initialValue parm
## 1 transitive triplets         TRUE    FALSE FALSE          0   0   
## 2 transitive recipr. triplets TRUE    FALSE FALSE          0   0
```

```r
NBeff &lt;- includeEffects( NBeff, egoX, egoSqX, altX, altSqX, diffSqX,
                         interaction1 = "smoke1"  )
```

```
##   effectName           include fix   test  initialValue parm
## 1 smoke1 alter         TRUE    FALSE FALSE          0   0   
## 2 smoke1 squared alter TRUE    FALSE FALSE          0   0   
## 3 smoke1 ego           TRUE    FALSE FALSE          0   0   
## 4 smoke1 squared ego   TRUE    FALSE FALSE          0   0   
## 5 smoke1 diff. squared TRUE    FALSE FALSE          0   0
```

```r
NBeff
```

```
##    name        effectName                          include fix   test 
## 1  friendship  constant friendship rate (period 1) TRUE    FALSE FALSE
## 2  friendship  constant friendship rate (period 2) TRUE    FALSE FALSE
## 3  friendship  outdegree (density)                 TRUE    FALSE FALSE
## 4  friendship  reciprocity                         TRUE    FALSE FALSE
## 5  friendship  transitive triplets                 TRUE    FALSE FALSE
## 6  friendship  transitive recipr. triplets         TRUE    FALSE FALSE
## 7  friendship  smoke1 alter                        TRUE    FALSE FALSE
## 8  friendship  smoke1 squared alter                TRUE    FALSE FALSE
## 9  friendship  smoke1 ego                          TRUE    FALSE FALSE
## 10 friendship  smoke1 squared ego                  TRUE    FALSE FALSE
## 11 friendship  smoke1 diff. squared                TRUE    FALSE FALSE
## 12 drinkingbeh rate drinkingbeh (period 1)         TRUE    FALSE FALSE
## 13 drinkingbeh rate drinkingbeh (period 2)         TRUE    FALSE FALSE
## 14 drinkingbeh drinkingbeh linear shape            TRUE    FALSE FALSE
## 15 drinkingbeh drinkingbeh quadratic shape         TRUE    FALSE FALSE
##    initialValue parm
## 1     4.69604   0   
## 2     4.32885   0   
## 3    -1.46770   0   
## 4     0.00000   0   
## 5     0.00000   0   
## 6     0.00000   0   
## 7     0.00000   0   
## 8     0.00000   0   
## 9     0.00000   0   
## 10    0.00000   0   
## 11    0.00000   0   
## 12    0.70571   0   
## 13    0.84939   0   
## 14    0.32237   0   
## 15    0.00000   0
```

---

## Define the Model:

```r
myalgorithm1 &lt;- sienaAlgorithmCreate( projname = 's50_NB' )

# Estimate using the second algorithm right from the start.
NBans &lt;- siena07(myalgorithm1, data = NBdata, effects = NBeff)
NBans &lt;- siena07(myalgorithm1, data = NBdata, effects = NBeff, batch=TRUE) #without Siena screen
```



---

## Look at results


```r
NBans
```

```
## Estimates, standard errors and convergence t-ratios
## 
##                                                Estimate   Standard   Convergence 
##                                                             Error      t-ratio   
## Network Dynamics 
##    1. rate constant friendship rate (period 1)  6.2738  ( 1.2186   )    0.0384   
##    2. rate constant friendship rate (period 2)  5.0845  ( 0.8572   )   -0.0337   
##    3. eval outdegree (density)                 -2.6246  ( 0.2222   )    0.0538   
##    4. eval reciprocity                          2.7737  ( 0.2664   )    0.0710   
##    5. eval transitive triplets                  0.8915  ( 0.1360   )    0.1005   
##    6. eval transitive recipr. triplets         -0.5130  ( 0.2160   )    0.1082   
##    7. eval smoke1 alter                         0.2548  ( 0.2914   )   -0.0221   
##    8. eval smoke1 squared alter                -0.2197  ( 0.2489   )    0.0047   
##    9. eval smoke1 ego                           0.0873  ( 0.3034   )    0.0015   
##   10. eval smoke1 squared ego                   0.0104  ( 0.2501   )    0.0322   
##   11. eval smoke1 diff. squared                -0.0981  ( 0.0679   )   -0.0047   
## 
## Behavior Dynamics
##   12. rate rate drinkingbeh (period 1)          1.1712  ( 0.3042   )   -0.0364   
##   13. rate rate drinkingbeh (period 2)          1.6518  ( 0.4074   )    0.0249   
##   14. eval drinkingbeh linear shape             0.3664  ( 0.1425   )    0.0079   
##   15. eval drinkingbeh quadratic shape         -0.2053  ( 0.0962   )   -0.0834   
## 
## Overall maximum convergence ratio:    0.1885 
## 
## 
## Total of 3435 iteration steps.
```

---

## Actors Entering and Exiting the Network



```r
library(devtools)
#install_github("ochyzh/networkdata")
data("duqueData")
dim(dipl_ties[[1]])
```

```
## [1] 134 134
```

```r
dim(dipl_ties[[2]])
```

```
## [1] 148 148
```

- Remember that in these data, time periods have varying numbers of observations, as states enter and leave the system.

- In order to use RSiena, we must have the same number of actors in each time period. If an actor is missing, their tie values are coded as either `NA` or some other code we will passed to `sienaCompositionChange` option (see the manual for the second option).

- Note: if you plan to use network analysis, you have to become very comfortable with these types of data issues.  

---

## Setting Up the DV


```r
library(tidyverse)
#get the full list of actors:
myactors&lt;-unique(do.call("c",lapply(dipl_ties,names)))
dyads&lt;-expand.grid(myactors,myactors)

dipl&lt;-array(NA, dim = c( 194, 194, 8 ),
	dimnames=list(myactors,myactors,seq(from=1970,to=2005,by=5)))

for(t in 1:8){
    d&lt;-dipl_ties[[t]]
	for(i in 1:nrow(d)){
	  for (j in 1:ncol(d)){
		a1 = names(d)[i]
		a2 = colnames(d)[j]
		val = as.numeric(as.character(d[i,j]))
		
		dipl[i,j,t] &lt;- val
		dipl[j,i,t] &lt;- val
	  }}
	}

dipl &lt;- sienaDependent(dipl)
```


---

## Your Turn

3. Set up `allies` and `contig` as edge-level covariates.

4. Set up `polity` as a time-varying node-level covariate.

5. Estimate a model that includes the following covariates: outdegree, reciprocity, transitive triplets, polity alter, polity ego, polity diff., contiguity, and allies.




---



```r
ans&lt;-readRDS("data/ans.rds")
summary(ans)
```

```
## Estimates, standard errors and convergence t-ratios
## 
##                                    Estimate   Standard   Convergence 
##                                                 Error      t-ratio   
## 
## Rate parameters: 
##   0.1      Rate parameter period 1 87.4577  ( 6.8145   )             
##   0.2      Rate parameter period 2 76.4185  ( 4.2766   )             
##   0.3      Rate parameter period 3 63.6222  ( 2.6922   )             
##   0.4      Rate parameter period 4  5.1526  ( 0.2161   )             
##   0.5      Rate parameter period 5 38.1545  ( 1.1522   )             
##   0.6      Rate parameter period 6  5.6488  ( 0.2027   )             
##   0.7      Rate parameter period 7  7.0067  ( 0.2222   )             
## 
## Other parameters: 
##   1.  eval degree (density)        -1.1331  (     NA   )    1.8070   
##   2.  eval GWESP (69)               0.2528  (     NA   )   -1.0283   
##   3.  eval cont                     0.3578  (     NA   )   -1.8619   
##   4.  eval ally                     0.5063  (     NA   )   -3.3637   
##   5.  eval dem alter                0.1103  (     NA   )   -1.4067   
##   6.  eval dem ego                  0.1170  (     NA   )   -1.4067   
## 
## Overall maximum convergence ratio:        NA 
## 
## 
## Total of 2669 iteration steps.
## 
## Covariance matrix of estimates (correlations below diagonal)
## 
##           NA           NA           NA           NA           NA           NA
##           NA           NA           NA           NA           NA           NA
##           NA           NA           NA           NA           NA           NA
##           NA           NA           NA           NA           NA           NA
##           NA           NA           NA           NA           NA           NA
##           NA           NA           NA           NA           NA           NA
## 
## Derivative matrix of expected statistics X by parameters:
## 
##    14916.097    66840.143      457.634     1383.172      158.374      158.374
##    28850.529   129919.761      895.051     2720.172      357.710      357.710
##      115.987      508.643      876.915      286.895      -83.234      -83.234
##      367.801     1555.217      297.414     3261.791      368.204      368.204
##      374.345     1713.593      -45.455      433.978     2572.515     2572.515
##      -99.449     -547.996     -111.691      340.877     2327.464     2327.464
## 
## Covariance matrix of X (correlations below diagonal):
## 
##     9978.793    44250.355      361.678      888.242      286.234      286.234
##        0.992   199220.579     1641.745     3835.241     1247.449     1247.449
##        0.107        0.109     1144.917      450.675      -10.450      -10.450
##        0.132        0.127        0.197     4556.780      790.709      790.709
##        0.049        0.048       -0.005        0.202     3365.417     3365.417
##        0.049        0.048       -0.005        0.202        1.000     3365.417
```


---

# TERGM vs. SAOM

- [Block et al. 2017](http://journals.sagepub.com/doi/abs/10.1177/0049124116672680)
- [Block et al. 2018](https://www.sciencedirect.com/science/article/pii/S0378873317300035)
- [Leifeld &amp; Cranmer 2018](https://arxiv.org/pdf/1506.06696.pdf)



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
